var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"Tilt_Telescopic_Switch","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"Tilt_Telescopic_Switch.h\"    /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  Tilt_Telescopic_Switch_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  Tilt_Telescopic_Switch_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 1.0E-5 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (1) {\n    /*  Perform application tasks here */\n  }\n\n  /* The option 'Remove error status field in real-time model data structure'\n   * is selected, therefore the following code does not need to execute.\n   */\n\n  /* Terminate model */\n  Tilt_Telescopic_Switch_terminate();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Tilt_Telescopic_Switch.c","type":"source","group":"model","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Tilt_Telescopic_Switch.c\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"Tilt_Telescopic_Switch.h\"\n#include \"rtwtypes.h\"\n#include \"enum_types.h\"\n#include \"Tilt_Telescopic_Switch_private.h\"\n#include \"tilt_tele_switch_func.h\"\n\n/* Named constants for Chart: '<S6>/Tilt_Down_Debounce_Logic' */\n#define Tilt_Telesco_IN_NO_ACTIVE_CHILD ((uint8_T)0U)\n#define Tilt_Telescopic_IN_Off_Debounce ((uint8_T)1U)\n#define Tilt_Telescopic_S_IN_Stuck_Wait ((uint8_T)6U)\n#define Tilt_Telescopic_Swi_IN_Debounce ((uint8_T)1U)\n#define Tilt_Telescopic_Swit_IN_Pressed ((uint8_T)4U)\n#define Tilt_Telescopic_Switch_IN_Off  ((uint8_T)3U)\n#define Tilt_Telescopic_Switch_IN_Stuck ((uint8_T)5U)\n#define Tilt_Telescopic__IN_Not_Pressed ((uint8_T)2U)\n#define Tilt_Telescopic__IN_On_Debounce ((uint8_T)2U)\n\n/* Exported data definition */\n\n/* Definition for custom storage class: Localizable */\nstatic TELE_INPUT Tele_Forward_Switch_Status_Delay;/* '<S9>/Unit Delay' */\nstatic TELE_INPUT Tele_Rearward_Switch_Status_Delay;/* '<S10>/Unit Delay' */\nstatic TILT_INPUT Tilt_Down_Switch_Status_Delay;/* '<S11>/Unit Delay' */\nstatic TILT_INPUT Tilt_Up_Switch_Status_Delay;/* '<S12>/Unit Delay' */\n\n/* Block signals (default storage) */\nB_Tilt_Telescopic_Switch_T Tilt_Telescopic_Switch_B;\n\n/* Block states (default storage) */\nDW_Tilt_Telescopic_Switch_T Tilt_Telescopic_Switch_DW;\n\n/* Real-time model */\nstatic RT_MODEL_Tilt_Telescopic_Swit_T Tilt_Telescopic_Switch_M_;\nRT_MODEL_Tilt_Telescopic_Swit_T *const Tilt_Telescopic_Switch_M =\n  &Tilt_Telescopic_Switch_M_;\nstatic void rate_scheduler(void);\n\n/*\n *         This function updates active task flag for each subrate.\n *         The function is called at model base rate, hence the\n *         generated code self-manages all its subrates.\n */\nstatic void rate_scheduler(void)\n{\n  /* Compute which subrates run during the next base time step.  Subrates\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\n   * counter is reset when it reaches its limit (zero means run).\n   */\n  (Tilt_Telescopic_Switch_M->Timing.TaskCounters.TID[1])++;\n  if ((Tilt_Telescopic_Switch_M->Timing.TaskCounters.TID[1]) > 999) {/* Sample time: [0.01s, 0.0s] */\n    Tilt_Telescopic_Switch_M->Timing.TaskCounters.TID[1] = 0;\n  }\n}\n\n/* Model step function */\nvoid Tilt_Telescopic_Switch_step(void)\n{\n  if (Tilt_Telescopic_Switch_M->Timing.TaskCounters.TID[1] == 0) {\n    /* Outputs for Enabled SubSystem: '<S2>/SwitchPos_Status_Determination' incorporates:\n     *  EnablePort: '<S4>/Enable'\n     */\n    /* Logic: '<S5>/Logical Operator' incorporates:\n     *  Constant: '<S3>/VMax'\n     *  Constant: '<S3>/VMin'\n     *  Inport: '<Root>/Input_Voltage'\n     *  Inport: '<Root>/Tilt_Tele_Config_Param'\n     *  Logic: '<S3>/Logical Operator'\n     *  RelationalOperator: '<S3>/Relational Operator'\n     *  RelationalOperator: '<S3>/Relational Operator1'\n     */\n    if (((Input_Voltage >= 10.0) && (Input_Voltage <= 20.0)) &&\n        Tilt_Tele_Config_Param) {\n      int32_T tmp;\n\n      /* Chart: '<S6>/Tilt_Down_Debounce_Logic' incorporates:\n       *  Constant: '<S6>/Constant'\n       *  Constant: '<S6>/Constant1'\n       *  Constant: '<S6>/Constant2'\n       *  DataStoreRead: '<S6>/Data Store Read'\n       *  Inport: '<Root>/Tilt_Down_Input'\n       */\n      if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_p < MAX_uint32_T) {\n        Tilt_Telescopic_Switch_DW.temporalCounter_i1_p++;\n      }\n\n      /* Gateway: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down/Tilt_Down_Debounce_Logic */\n      /* During: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down/Tilt_Down_Debounce_Logic */\n      if (Tilt_Telescopic_Switch_DW.is_active_c1_Tilt_Telescopic_Sw == 0U) {\n        /* Entry: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down/Tilt_Down_Debounce_Logic */\n        Tilt_Telescopic_Switch_DW.is_active_c1_Tilt_Telescopic_Sw = 1U;\n\n        /* Entry Internal: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down/Tilt_Down_Debounce_Logic */\n        /* Transition: '<S14>:2' */\n        Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n          Tilt_Telescopic__IN_Not_Pressed;\n\n        /* Entry 'Not_Pressed': '<S14>:1' */\n        Tilt_Telescopic_Switch_B.Down_Switch_Output = false;\n      } else {\n        switch (Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch) {\n         case Tilt_Telescopic_Swi_IN_Debounce:\n          /* During 'Debounce': '<S14>:3' */\n          if ((Tilt_Telescopic_Switch_DW.is_Debounce_a !=\n               Tilt_Telescopic_IN_Off_Debounce) &&\n              (Tilt_Telescopic_Switch_DW.temporalCounter_i1_p >= ((uint32_T)\n                (k_switchdebounce_time * 100)))) {\n            /* During 'On_Debounce': '<S14>:4' */\n            /* Transition: '<S14>:11' */\n            Tilt_Telescopic_Switch_DW.is_Debounce_a =\n              Tilt_Telesco_IN_NO_ACTIVE_CHILD;\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swit_IN_Pressed;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_p = 0U;\n\n            /* Entry 'Pressed': '<S14>:6' */\n            Tilt_Telescopic_Switch_B.Down_Switch_Output = true;\n          } else {\n            /* During 'Off_Debounce': '<S14>:5' */\n          }\n          break;\n\n         case Tilt_Telescopic__IN_Not_Pressed:\n          Tilt_Telescopic_Switch_B.Down_Switch_Output = false;\n\n          /* During 'Not_Pressed': '<S14>:1' */\n          if ((!Tilt_Down_Stuck_Switch) && Tilt_Down_Input) {\n            /* Transition: '<S14>:10' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_a =\n              Tilt_Telescopic__IN_On_Debounce;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_p = 0U;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Off:\n          /* During 'Off': '<S14>:9' */\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_p >= ((uint32_T)\n               (k_switchrelease_time * 100))) {\n            /* Transition: '<S14>:17' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic__IN_Not_Pressed;\n\n            /* Entry 'Not_Pressed': '<S14>:1' */\n            Tilt_Telescopic_Switch_B.Down_Switch_Output = false;\n          }\n          break;\n\n         case Tilt_Telescopic_Swit_IN_Pressed:\n          Tilt_Telescopic_Switch_B.Down_Switch_Output = true;\n\n          /* During 'Pressed': '<S14>:6' */\n          tmp = (k_switchstuck_time - k_switchdebounce_time) * 100;\n          if (tmp < 0) {\n            tmp = 0;\n          }\n\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_p >= ((uint32_T)tmp))\n          {\n            /* Transition: '<S14>:18' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_S_IN_Stuck_Wait;\n          } else {\n            /* Transition: '<S14>:19' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_a =\n              Tilt_Telescopic_IN_Off_Debounce;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Stuck:\n          Tilt_Telescopic_Switch_B.Down_Switch_Output = false;\n          Tilt_Telescopic_Switch_B.Switch_Stuck_i = true;\n\n          /* During 'Stuck': '<S14>:8' */\n          if (!Tilt_Down_Input) {\n            /* Transition: '<S14>:16' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Off;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_p = 0U;\n          }\n          break;\n\n         default:\n          /* During 'Stuck_Wait': '<S14>:7' */\n          if (Tilt_Down_Input) {\n            /* Transition: '<S14>:15' */\n            Tilt_Telescopic_Switch_DW.is_c1_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Stuck;\n\n            /* Entry 'Stuck': '<S14>:8' */\n            Tilt_Telescopic_Switch_B.Down_Switch_Output = false;\n            Tilt_Telescopic_Switch_B.Switch_Stuck_i = true;\n          }\n          break;\n        }\n      }\n\n      /* End of Chart: '<S6>/Tilt_Down_Debounce_Logic' */\n\n      /* DataStoreWrite: '<S6>/Data Store Write' */\n      Tilt_Down_Stuck_Switch = Tilt_Telescopic_Switch_B.Switch_Stuck_i;\n\n      /* Chart: '<S7>/Tele_Forward_Debounce_Logic' incorporates:\n       *  Constant: '<S7>/Constant3'\n       *  Constant: '<S7>/Constant4'\n       *  Constant: '<S7>/Constant5'\n       *  DataStoreRead: '<S7>/Data Store Read'\n       *  Inport: '<Root>/Tele_Forward_Input'\n       */\n      if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_g < MAX_uint32_T) {\n        Tilt_Telescopic_Switch_DW.temporalCounter_i1_g++;\n      }\n\n      /* Gateway: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward/Tele_Forward_Debounce_Logic */\n      /* During: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward/Tele_Forward_Debounce_Logic */\n      if (Tilt_Telescopic_Switch_DW.is_active_c2_Tilt_Telescopic_Sw == 0U) {\n        /* Entry: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward/Tele_Forward_Debounce_Logic */\n        Tilt_Telescopic_Switch_DW.is_active_c2_Tilt_Telescopic_Sw = 1U;\n\n        /* Entry Internal: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward/Tele_Forward_Debounce_Logic */\n        /* Transition: '<S15>:2' */\n        Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n          Tilt_Telescopic__IN_Not_Pressed;\n\n        /* Entry 'Not_Pressed': '<S15>:1' */\n        Tilt_Telescopic_Switch_B.Forward_Switch_Output = false;\n      } else {\n        switch (Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch) {\n         case Tilt_Telescopic_Swi_IN_Debounce:\n          /* During 'Debounce': '<S15>:3' */\n          if ((Tilt_Telescopic_Switch_DW.is_Debounce_f !=\n               Tilt_Telescopic_IN_Off_Debounce) &&\n              (Tilt_Telescopic_Switch_DW.temporalCounter_i1_g >= ((uint32_T)\n                (k_switchdebounce_time * 100)))) {\n            /* During 'On_Debounce': '<S15>:4' */\n            /* Transition: '<S15>:11' */\n            Tilt_Telescopic_Switch_DW.is_Debounce_f =\n              Tilt_Telesco_IN_NO_ACTIVE_CHILD;\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swit_IN_Pressed;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_g = 0U;\n\n            /* Entry 'Pressed': '<S15>:6' */\n            Tilt_Telescopic_Switch_B.Forward_Switch_Output = true;\n          } else {\n            /* During 'Off_Debounce': '<S15>:5' */\n          }\n          break;\n\n         case Tilt_Telescopic__IN_Not_Pressed:\n          Tilt_Telescopic_Switch_B.Forward_Switch_Output = false;\n\n          /* During 'Not_Pressed': '<S15>:1' */\n          if ((!Tele_Forward_Stuck_Switch) && Tele_Forward_Input) {\n            /* Transition: '<S15>:10' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_f =\n              Tilt_Telescopic__IN_On_Debounce;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_g = 0U;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Off:\n          /* During 'Off': '<S15>:9' */\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_g >= ((uint32_T)\n               (k_switchrelease_time * 100))) {\n            /* Transition: '<S15>:17' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic__IN_Not_Pressed;\n\n            /* Entry 'Not_Pressed': '<S15>:1' */\n            Tilt_Telescopic_Switch_B.Forward_Switch_Output = false;\n          }\n          break;\n\n         case Tilt_Telescopic_Swit_IN_Pressed:\n          Tilt_Telescopic_Switch_B.Forward_Switch_Output = true;\n\n          /* During 'Pressed': '<S15>:6' */\n          tmp = (k_switchstuck_time - k_switchdebounce_time) * 100;\n          if (tmp < 0) {\n            tmp = 0;\n          }\n\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_g >= ((uint32_T)tmp))\n          {\n            /* Transition: '<S15>:18' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_S_IN_Stuck_Wait;\n          } else {\n            /* Transition: '<S15>:19' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_f =\n              Tilt_Telescopic_IN_Off_Debounce;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Stuck:\n          Tilt_Telescopic_Switch_B.Forward_Switch_Output = false;\n          Tilt_Telescopic_Switch_B.Switch_Stuck_l = true;\n\n          /* During 'Stuck': '<S15>:8' */\n          if (!Tele_Forward_Input) {\n            /* Transition: '<S15>:16' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Off;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_g = 0U;\n          }\n          break;\n\n         default:\n          /* During 'Stuck_Wait': '<S15>:7' */\n          if (Tele_Forward_Input) {\n            /* Transition: '<S15>:15' */\n            Tilt_Telescopic_Switch_DW.is_c2_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Stuck;\n\n            /* Entry 'Stuck': '<S15>:8' */\n            Tilt_Telescopic_Switch_B.Forward_Switch_Output = false;\n            Tilt_Telescopic_Switch_B.Switch_Stuck_l = true;\n          }\n          break;\n        }\n      }\n\n      /* End of Chart: '<S7>/Tele_Forward_Debounce_Logic' */\n\n      /* DataStoreWrite: '<S7>/Data Store Write' */\n      Tele_Forward_Stuck_Switch = Tilt_Telescopic_Switch_B.Switch_Stuck_l;\n\n      /* Chart: '<S8>/Tele_Rearward_Debounce_Logic' incorporates:\n       *  Constant: '<S8>/Constant3'\n       *  Constant: '<S8>/Constant4'\n       *  Constant: '<S8>/Constant5'\n       *  DataStoreRead: '<S8>/Data Store Read'\n       *  Inport: '<Root>/Tele_Rearward_Input'\n       */\n      if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_d < MAX_uint32_T) {\n        Tilt_Telescopic_Switch_DW.temporalCounter_i1_d++;\n      }\n\n      /* Gateway: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward/Tele_Rearward_Debounce_Logic */\n      /* During: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward/Tele_Rearward_Debounce_Logic */\n      if (Tilt_Telescopic_Switch_DW.is_active_c4_Tilt_Telescopic_Sw == 0U) {\n        /* Entry: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward/Tele_Rearward_Debounce_Logic */\n        Tilt_Telescopic_Switch_DW.is_active_c4_Tilt_Telescopic_Sw = 1U;\n\n        /* Entry Internal: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward/Tele_Rearward_Debounce_Logic */\n        /* Transition: '<S16>:2' */\n        Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n          Tilt_Telescopic__IN_Not_Pressed;\n\n        /* Entry 'Not_Pressed': '<S16>:1' */\n        Tilt_Telescopic_Switch_B.Rearward_Switch_Output = false;\n      } else {\n        switch (Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch) {\n         case Tilt_Telescopic_Swi_IN_Debounce:\n          /* During 'Debounce': '<S16>:3' */\n          if ((Tilt_Telescopic_Switch_DW.is_Debounce_o !=\n               Tilt_Telescopic_IN_Off_Debounce) &&\n              (Tilt_Telescopic_Switch_DW.temporalCounter_i1_d >= ((uint32_T)\n                (k_switchdebounce_time * 100)))) {\n            /* During 'On_Debounce': '<S16>:4' */\n            /* Transition: '<S16>:11' */\n            Tilt_Telescopic_Switch_DW.is_Debounce_o =\n              Tilt_Telesco_IN_NO_ACTIVE_CHILD;\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swit_IN_Pressed;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_d = 0U;\n\n            /* Entry 'Pressed': '<S16>:6' */\n            Tilt_Telescopic_Switch_B.Rearward_Switch_Output = true;\n          } else {\n            /* During 'Off_Debounce': '<S16>:5' */\n          }\n          break;\n\n         case Tilt_Telescopic__IN_Not_Pressed:\n          Tilt_Telescopic_Switch_B.Rearward_Switch_Output = false;\n\n          /* During 'Not_Pressed': '<S16>:1' */\n          if ((!Tele_Rearward_Stuck_Switch) && Tele_Rearward_Input) {\n            /* Transition: '<S16>:10' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_o =\n              Tilt_Telescopic__IN_On_Debounce;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_d = 0U;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Off:\n          /* During 'Off': '<S16>:9' */\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_d >= ((uint32_T)\n               (k_switchrelease_time * 100))) {\n            /* Transition: '<S16>:17' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic__IN_Not_Pressed;\n\n            /* Entry 'Not_Pressed': '<S16>:1' */\n            Tilt_Telescopic_Switch_B.Rearward_Switch_Output = false;\n          }\n          break;\n\n         case Tilt_Telescopic_Swit_IN_Pressed:\n          Tilt_Telescopic_Switch_B.Rearward_Switch_Output = true;\n\n          /* During 'Pressed': '<S16>:6' */\n          tmp = (k_switchstuck_time - k_switchdebounce_time) * 100;\n          if (tmp < 0) {\n            tmp = 0;\n          }\n\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1_d >= ((uint32_T)tmp))\n          {\n            /* Transition: '<S16>:18' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_S_IN_Stuck_Wait;\n          } else {\n            /* Transition: '<S16>:19' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce_o =\n              Tilt_Telescopic_IN_Off_Debounce;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Stuck:\n          Tilt_Telescopic_Switch_B.Rearward_Switch_Output = false;\n          Tilt_Telescopic_Switch_B.Switch_Stuck_j = true;\n\n          /* During 'Stuck': '<S16>:8' */\n          if (!Tele_Rearward_Input) {\n            /* Transition: '<S16>:16' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Off;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1_d = 0U;\n          }\n          break;\n\n         default:\n          /* During 'Stuck_Wait': '<S16>:7' */\n          if (Tele_Rearward_Input) {\n            /* Transition: '<S16>:15' */\n            Tilt_Telescopic_Switch_DW.is_c4_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Stuck;\n\n            /* Entry 'Stuck': '<S16>:8' */\n            Tilt_Telescopic_Switch_B.Rearward_Switch_Output = false;\n            Tilt_Telescopic_Switch_B.Switch_Stuck_j = true;\n          }\n          break;\n        }\n      }\n\n      /* End of Chart: '<S8>/Tele_Rearward_Debounce_Logic' */\n\n      /* DataStoreWrite: '<S8>/Data Store Write' */\n      Tele_Rearward_Stuck_Switch = Tilt_Telescopic_Switch_B.Switch_Stuck_j;\n\n      /* Chart: '<S13>/Tilt_Up_Debounce_Logic' incorporates:\n       *  Constant: '<S13>/Constant'\n       *  Constant: '<S13>/Constant1'\n       *  Constant: '<S13>/Constant2'\n       *  DataStoreRead: '<S13>/Data Store Read'\n       *  Inport: '<Root>/Tilt_Up_Input'\n       */\n      if (Tilt_Telescopic_Switch_DW.temporalCounter_i1 < MAX_uint32_T) {\n        Tilt_Telescopic_Switch_DW.temporalCounter_i1++;\n      }\n\n      /* Gateway: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up/Tilt_Up_Debounce_Logic */\n      /* During: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up/Tilt_Up_Debounce_Logic */\n      if (Tilt_Telescopic_Switch_DW.is_active_c3_Tilt_Telescopic_Sw == 0U) {\n        /* Entry: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up/Tilt_Up_Debounce_Logic */\n        Tilt_Telescopic_Switch_DW.is_active_c3_Tilt_Telescopic_Sw = 1U;\n\n        /* Entry Internal: Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up/Tilt_Up_Debounce_Logic */\n        /* Transition: '<S21>:2' */\n        Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n          Tilt_Telescopic__IN_Not_Pressed;\n\n        /* Entry 'Not_Pressed': '<S21>:1' */\n        Tilt_Telescopic_Switch_B.Up_Switch_Output = false;\n      } else {\n        switch (Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch) {\n         case Tilt_Telescopic_Swi_IN_Debounce:\n          /* During 'Debounce': '<S21>:3' */\n          if ((Tilt_Telescopic_Switch_DW.is_Debounce !=\n               Tilt_Telescopic_IN_Off_Debounce) &&\n              (Tilt_Telescopic_Switch_DW.temporalCounter_i1 >= ((uint32_T)\n                (k_switchdebounce_time * 100)))) {\n            /* During 'On_Debounce': '<S21>:4' */\n            /* Transition: '<S21>:11' */\n            Tilt_Telescopic_Switch_DW.is_Debounce =\n              Tilt_Telesco_IN_NO_ACTIVE_CHILD;\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swit_IN_Pressed;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1 = 0U;\n\n            /* Entry 'Pressed': '<S21>:6' */\n            Tilt_Telescopic_Switch_B.Up_Switch_Output = true;\n          } else {\n            /* During 'Off_Debounce': '<S21>:5' */\n          }\n          break;\n\n         case Tilt_Telescopic__IN_Not_Pressed:\n          Tilt_Telescopic_Switch_B.Up_Switch_Output = false;\n\n          /* During 'Not_Pressed': '<S21>:1' */\n          if ((!Tilt_Up_Stuck_Switch) && Tilt_Up_Input) {\n            /* Transition: '<S21>:10' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce =\n              Tilt_Telescopic__IN_On_Debounce;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1 = 0U;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Off:\n          /* During 'Off': '<S21>:9' */\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1 >= ((uint32_T)\n               (k_switchrelease_time * 100))) {\n            /* Transition: '<S21>:17' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic__IN_Not_Pressed;\n\n            /* Entry 'Not_Pressed': '<S21>:1' */\n            Tilt_Telescopic_Switch_B.Up_Switch_Output = false;\n          }\n          break;\n\n         case Tilt_Telescopic_Swit_IN_Pressed:\n          Tilt_Telescopic_Switch_B.Up_Switch_Output = true;\n\n          /* During 'Pressed': '<S21>:6' */\n          tmp = (k_switchstuck_time - k_switchdebounce_time) * 100;\n          if (tmp < 0) {\n            tmp = 0;\n          }\n\n          if (Tilt_Telescopic_Switch_DW.temporalCounter_i1 >= ((uint32_T)tmp)) {\n            /* Transition: '<S21>:18' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_S_IN_Stuck_Wait;\n          } else {\n            /* Transition: '<S21>:19' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Swi_IN_Debounce;\n            Tilt_Telescopic_Switch_DW.is_Debounce =\n              Tilt_Telescopic_IN_Off_Debounce;\n          }\n          break;\n\n         case Tilt_Telescopic_Switch_IN_Stuck:\n          Tilt_Telescopic_Switch_B.Up_Switch_Output = false;\n          Tilt_Telescopic_Switch_B.Switch_Stuck = true;\n\n          /* During 'Stuck': '<S21>:8' */\n          if (!Tilt_Up_Input) {\n            /* Transition: '<S21>:16' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Off;\n            Tilt_Telescopic_Switch_DW.temporalCounter_i1 = 0U;\n          }\n          break;\n\n         default:\n          /* During 'Stuck_Wait': '<S21>:7' */\n          if (Tilt_Up_Input) {\n            /* Transition: '<S21>:15' */\n            Tilt_Telescopic_Switch_DW.is_c3_Tilt_Telescopic_Switch =\n              Tilt_Telescopic_Switch_IN_Stuck;\n\n            /* Entry 'Stuck': '<S21>:8' */\n            Tilt_Telescopic_Switch_B.Up_Switch_Output = false;\n            Tilt_Telescopic_Switch_B.Switch_Stuck = true;\n          }\n          break;\n        }\n      }\n\n      /* End of Chart: '<S13>/Tilt_Up_Debounce_Logic' */\n\n      /* DataStoreWrite: '<S13>/Data Store Write' */\n      Tilt_Up_Stuck_Switch = Tilt_Telescopic_Switch_B.Switch_Stuck;\n\n      /* Switch: '<S9>/Switch' incorporates:\n       *  Constant: '<S17>/Constant'\n       *  RelationalOperator: '<S17>/Compare'\n       *  Sum: '<S4>/Add'\n       *  Switch: '<S10>/Switch'\n       *  Switch: '<S11>/Switch'\n       *  Switch: '<S12>/Switch'\n       *  Switch: '<S9>/Switch1'\n       */\n      if (((int32_T)(((((uint32_T)Tilt_Telescopic_Switch_B.Up_Switch_Output) +\n                       Tilt_Telescopic_Switch_B.Down_Switch_Output) +\n                      Tilt_Telescopic_Switch_B.Forward_Switch_Output) +\n                     Tilt_Telescopic_Switch_B.Rearward_Switch_Output)) >\n          ((uint8_T)1U)) {\n        /* Switch: '<S9>/Switch' incorporates:\n         *  UnitDelay: '<S9>/Unit Delay'\n         */\n        Tele_Forward_Switch_Status = Tele_Forward_Switch_Status_Delay;\n\n        /* Switch: '<S10>/Switch' incorporates:\n         *  UnitDelay: '<S10>/Unit Delay'\n         */\n        Tele_Rearward_Switch_Status = Tele_Rearward_Switch_Status_Delay;\n\n        /* Switch: '<S11>/Switch' incorporates:\n         *  UnitDelay: '<S11>/Unit Delay'\n         */\n        Tilt_Down_Switch_Status = Tilt_Down_Switch_Status_Delay;\n\n        /* Switch: '<S12>/Switch' incorporates:\n         *  UnitDelay: '<S12>/Unit Delay'\n         */\n        Tilt_Up_Switch_Status = Tilt_Up_Switch_Status_Delay;\n      } else {\n        if (Tilt_Telescopic_Switch_B.Forward_Switch_Output) {\n          /* Switch: '<S9>/Switch1' incorporates:\n           *  Constant: '<S9>/Forward'\n           *  Switch: '<S9>/Switch'\n           */\n          Tele_Forward_Switch_Status = TELE_Forward;\n        } else {\n          /* Switch: '<S9>/Switch' incorporates:\n           *  Constant: '<S9>/Off'\n           *  Switch: '<S9>/Switch1'\n           */\n          Tele_Forward_Switch_Status = TELE_Off;\n        }\n\n        /* Switch: '<S10>/Switch1' */\n        if (Tilt_Telescopic_Switch_B.Rearward_Switch_Output) {\n          /* Switch: '<S10>/Switch' incorporates:\n           *  Constant: '<S10>/Rearward'\n           */\n          Tele_Rearward_Switch_Status = TELE_Rearward;\n        } else {\n          /* Switch: '<S10>/Switch' incorporates:\n           *  Constant: '<S10>/Off'\n           */\n          Tele_Rearward_Switch_Status = TELE_Off;\n        }\n\n        /* End of Switch: '<S10>/Switch1' */\n\n        /* Switch: '<S11>/Switch1' */\n        if (Tilt_Telescopic_Switch_B.Down_Switch_Output) {\n          /* Switch: '<S11>/Switch' incorporates:\n           *  Constant: '<S11>/Down'\n           */\n          Tilt_Down_Switch_Status = TILT_Down;\n        } else {\n          /* Switch: '<S11>/Switch' incorporates:\n           *  Constant: '<S11>/Off'\n           */\n          Tilt_Down_Switch_Status = TILT_Off;\n        }\n\n        /* End of Switch: '<S11>/Switch1' */\n\n        /* Switch: '<S12>/Switch1' */\n        if (Tilt_Telescopic_Switch_B.Up_Switch_Output) {\n          /* Switch: '<S12>/Switch' incorporates:\n           *  Constant: '<S12>/Up'\n           */\n          Tilt_Up_Switch_Status = TILT_Up;\n        } else {\n          /* Switch: '<S12>/Switch' incorporates:\n           *  Constant: '<S12>/Off'\n           */\n          Tilt_Up_Switch_Status = TILT_Off;\n        }\n\n        /* End of Switch: '<S12>/Switch1' */\n      }\n\n      /* End of Switch: '<S9>/Switch' */\n\n      /* Update for UnitDelay: '<S9>/Unit Delay' */\n      Tele_Forward_Switch_Status_Delay = Tele_Forward_Switch_Status;\n\n      /* Update for UnitDelay: '<S10>/Unit Delay' */\n      Tele_Rearward_Switch_Status_Delay = Tele_Rearward_Switch_Status;\n\n      /* Update for UnitDelay: '<S11>/Unit Delay' */\n      Tilt_Down_Switch_Status_Delay = Tilt_Down_Switch_Status;\n\n      /* Update for UnitDelay: '<S12>/Unit Delay' */\n      Tilt_Up_Switch_Status_Delay = Tilt_Up_Switch_Status;\n    }\n\n    /* End of Logic: '<S5>/Logical Operator' */\n    /* End of Outputs for SubSystem: '<S2>/SwitchPos_Status_Determination' */\n  }\n\n  rate_scheduler();\n}\n\n/* Model initialize function */\nvoid Tilt_Telescopic_Switch_initialize(void)\n{\n  /* Registration code */\n\n  /* block I/O */\n\n  /* custom signals */\n  Tilt_Down_Switch_Status = TILT_Up;\n  Tilt_Up_Switch_Status = TILT_Up;\n  Tele_Forward_Switch_Status = TELE_Forward;\n  Tele_Rearward_Switch_Status = TELE_Forward;\n\n  /* states (dwork) */\n\n  /* custom states */\n  Tele_Forward_Switch_Status_Delay = TELE_Forward;\n  Tele_Rearward_Switch_Status_Delay = TELE_Forward;\n  Tilt_Down_Switch_Status_Delay = TILT_Up;\n  Tilt_Up_Switch_Status_Delay = TILT_Up;\n\n  /* SystemInitialize for Enabled SubSystem: '<S2>/SwitchPos_Status_Determination' */\n  /* InitializeConditions for UnitDelay: '<S9>/Unit Delay' */\n  Tele_Forward_Switch_Status_Delay = TELE_Off;\n\n  /* InitializeConditions for UnitDelay: '<S10>/Unit Delay' */\n  Tele_Rearward_Switch_Status_Delay = TELE_Off;\n\n  /* InitializeConditions for UnitDelay: '<S11>/Unit Delay' */\n  Tilt_Down_Switch_Status_Delay = TILT_Off;\n\n  /* InitializeConditions for UnitDelay: '<S12>/Unit Delay' */\n  Tilt_Up_Switch_Status_Delay = TILT_Off;\n\n  /* End of SystemInitialize for SubSystem: '<S2>/SwitchPos_Status_Determination' */\n}\n\n/* Model terminate function */\nvoid Tilt_Telescopic_Switch_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Tilt_Telescopic_Switch.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Tilt_Telescopic_Switch.h\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Tilt_Telescopic_Switch_h_\n#define RTW_HEADER_Tilt_Telescopic_Switch_h_\n#ifndef Tilt_Telescopic_Switch_COMMON_INCLUDES_\n#define Tilt_Telescopic_Switch_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#endif                             /* Tilt_Telescopic_Switch_COMMON_INCLUDES_ */\n\n#include \"Tilt_Telescopic_Switch_types.h\"\n#include \"enum_types.h\"\n\n/* Includes for objects with custom storage classes */\n#include \"tilt_tele_switch_func.h\"\n\n/* Block signals (default storage) */\ntypedef struct {\n  boolean_T Up_Switch_Output;          /* '<S13>/Tilt_Up_Debounce_Logic' */\n  boolean_T Switch_Stuck;              /* '<S13>/Tilt_Up_Debounce_Logic' */\n  boolean_T Rearward_Switch_Output;    /* '<S8>/Tele_Rearward_Debounce_Logic' */\n  boolean_T Switch_Stuck_j;            /* '<S8>/Tele_Rearward_Debounce_Logic' */\n  boolean_T Forward_Switch_Output;     /* '<S7>/Tele_Forward_Debounce_Logic' */\n  boolean_T Switch_Stuck_l;            /* '<S7>/Tele_Forward_Debounce_Logic' */\n  boolean_T Down_Switch_Output;        /* '<S6>/Tilt_Down_Debounce_Logic' */\n  boolean_T Switch_Stuck_i;            /* '<S6>/Tilt_Down_Debounce_Logic' */\n} B_Tilt_Telescopic_Switch_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  uint32_T temporalCounter_i1;         /* '<S13>/Tilt_Up_Debounce_Logic' */\n  uint32_T temporalCounter_i1_d;       /* '<S8>/Tele_Rearward_Debounce_Logic' */\n  uint32_T temporalCounter_i1_g;       /* '<S7>/Tele_Forward_Debounce_Logic' */\n  uint32_T temporalCounter_i1_p;       /* '<S6>/Tilt_Down_Debounce_Logic' */\n  uint8_T is_active_c3_Tilt_Telescopic_Sw;/* '<S13>/Tilt_Up_Debounce_Logic' */\n  uint8_T is_c3_Tilt_Telescopic_Switch;/* '<S13>/Tilt_Up_Debounce_Logic' */\n  uint8_T is_Debounce;                 /* '<S13>/Tilt_Up_Debounce_Logic' */\n  uint8_T is_active_c4_Tilt_Telescopic_Sw;/* '<S8>/Tele_Rearward_Debounce_Logic' */\n  uint8_T is_c4_Tilt_Telescopic_Switch;/* '<S8>/Tele_Rearward_Debounce_Logic' */\n  uint8_T is_Debounce_o;               /* '<S8>/Tele_Rearward_Debounce_Logic' */\n  uint8_T is_active_c2_Tilt_Telescopic_Sw;/* '<S7>/Tele_Forward_Debounce_Logic' */\n  uint8_T is_c2_Tilt_Telescopic_Switch;/* '<S7>/Tele_Forward_Debounce_Logic' */\n  uint8_T is_Debounce_f;               /* '<S7>/Tele_Forward_Debounce_Logic' */\n  uint8_T is_active_c1_Tilt_Telescopic_Sw;/* '<S6>/Tilt_Down_Debounce_Logic' */\n  uint8_T is_c1_Tilt_Telescopic_Switch;/* '<S6>/Tilt_Down_Debounce_Logic' */\n  uint8_T is_Debounce_a;               /* '<S6>/Tilt_Down_Debounce_Logic' */\n} DW_Tilt_Telescopic_Switch_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_Tilt_Telescopic_Switc_T {\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    struct {\n      uint16_T TID[2];\n    } TaskCounters;\n  } Timing;\n};\n\n/* Block signals (default storage) */\nextern B_Tilt_Telescopic_Switch_T Tilt_Telescopic_Switch_B;\n\n/* Block states (default storage) */\nextern DW_Tilt_Telescopic_Switch_T Tilt_Telescopic_Switch_DW;\n\n/* Model entry point functions */\nextern void Tilt_Telescopic_Switch_initialize(void);\nextern void Tilt_Telescopic_Switch_step(void);\nextern void Tilt_Telescopic_Switch_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_Tilt_Telescopic_Swit_T *const Tilt_Telescopic_Switch_M;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'Tilt_Telescopic_Switch'\n * '<S1>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch'\n * '<S2>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele'\n * '<S3>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Valid_Voltage'\n * '<S4>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination'\n * '<S5>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/Tilt_Tele_Enabled_Condition'\n * '<S6>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down'\n * '<S7>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward'\n * '<S8>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward'\n * '<S9>'   : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tele_Forward_Status'\n * '<S10>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tele_Rearward_Status'\n * '<S11>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tilt_Down_Status'\n * '<S12>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tilt_Up_Status'\n * '<S13>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up'\n * '<S14>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Down/Tilt_Down_Debounce_Logic'\n * '<S15>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Forward/Tele_Forward_Debounce_Logic'\n * '<S16>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Rearward/Tele_Rearward_Debounce_Logic'\n * '<S17>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tele_Forward_Status/Compare To Constant'\n * '<S18>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tele_Rearward_Status/Compare To Constant'\n * '<S19>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tilt_Down_Status/Compare To Constant'\n * '<S20>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Tilt_Up_Status/Compare To Constant'\n * '<S21>'  : 'Tilt_Telescopic_Switch/Tilt_Tele_Switch/Power_Tilt_Tele/SwitchPos_Status_Determination/Up/Tilt_Up_Debounce_Logic'\n */\n#endif                                /* RTW_HEADER_Tilt_Telescopic_Switch_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Tilt_Telescopic_Switch_private.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Tilt_Telescopic_Switch_private.h\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Tilt_Telescopic_Switch_private_h_\n#define RTW_HEADER_Tilt_Telescopic_Switch_private_h_\n#include \"rtwtypes.h\"\n\n/* Imported (extern) block signals */\nextern uint8_T Input_Voltage;          /* '<Root>/Input_Voltage' */\nextern boolean_T Tilt_Tele_Config_Param;/* '<Root>/Tilt_Tele_Config_Param' */\nextern boolean_T Tilt_Up_Input;        /* '<Root>/Tilt_Up_Input' */\nextern boolean_T Tilt_Down_Input;      /* '<Root>/Tilt_Down_Input' */\nextern boolean_T Tele_Forward_Input;   /* '<Root>/Tele_Forward_Input' */\nextern boolean_T Tele_Rearward_Input;  /* '<Root>/Tele_Rearward_Input' */\n\n/* Imported (extern) states */\nextern boolean_T Tilt_Down_Stuck_Switch;/* '<S6>/Data Store Memory' */\nextern boolean_T Tele_Forward_Stuck_Switch;/* '<S7>/Data Store Memory' */\nextern boolean_T Tele_Rearward_Stuck_Switch;/* '<S8>/Data Store Memory' */\nextern boolean_T Tilt_Up_Stuck_Switch; /* '<S13>/Data Store Memory' */\n\n#endif                        /* RTW_HEADER_Tilt_Telescopic_Switch_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"Tilt_Telescopic_Switch_types.h","type":"header","group":"model","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: Tilt_Telescopic_Switch_types.h\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_Tilt_Telescopic_Switch_types_h_\n#define RTW_HEADER_Tilt_Telescopic_Switch_types_h_\n#include \"enum_types.h\"\n\n/* Model Code Variants */\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_Tilt_Telescopic_Switc_T RT_MODEL_Tilt_Telescopic_Swit_T;\n\n#endif                          /* RTW_HEADER_Tilt_Telescopic_Switch_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"tilt_tele_switch_func.h","type":"header","group":"data","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: tilt_tele_switch_func.h\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_tilt_tele_switch_func_h_\n#define RTW_HEADER_tilt_tele_switch_func_h_\n#include \"enum_types.h\"\n#include \"rtwtypes.h\"\n#include \"Tilt_Telescopic_Switch_types.h\"\n\n/* Exported data declaration */\n\n/* Declaration for custom storage class: ExportToFile */\nextern TELE_INPUT Tele_Forward_Switch_Status;/* '<S9>/Switch' */\nextern TELE_INPUT Tele_Rearward_Switch_Status;/* '<S10>/Switch' */\nextern TILT_INPUT Tilt_Down_Switch_Status;/* '<S11>/Switch' */\nextern TILT_INPUT Tilt_Up_Switch_Status;/* '<S12>/Switch' */\n\n/* ConstVolatile memory section */\n/* Declaration for custom storage class: ConstVolatile */\nextern const volatile uint8_T k_switchdebounce_time;/* Referenced by:\n                                                     * '<S6>/Constant2'\n                                                     * '<S7>/Constant5'\n                                                     * '<S8>/Constant5'\n                                                     * '<S13>/Constant2'\n                                                     */\nextern const volatile uint8_T k_switchrelease_time;/* Referenced by:\n                                                    * '<S6>/Constant'\n                                                    * '<S7>/Constant3'\n                                                    * '<S8>/Constant3'\n                                                    * '<S13>/Constant'\n                                                    */\nextern const volatile uint8_T k_switchstuck_time;/* Referenced by:\n                                                  * '<S6>/Constant1'\n                                                  * '<S7>/Constant4'\n                                                  * '<S8>/Constant4'\n                                                  * '<S13>/Constant1'\n                                                  */\n\n#endif                                 /* RTW_HEADER_tilt_tele_switch_func_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"tilt_tele_switch_func_RAM.c","type":"source","group":"data","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: tilt_tele_switch_func_RAM.c\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"tilt_tele_switch_func.h\"\n#include \"rtwtypes.h\"\n#include \"Tilt_Telescopic_Switch_types.h\"\n\n/* Exported data definition */\n\n/* Definition for custom storage class: ExportToFile */\nTELE_INPUT Tele_Forward_Switch_Status; /* '<S9>/Switch' */\nTELE_INPUT Tele_Rearward_Switch_Status;/* '<S10>/Switch' */\nTILT_INPUT Tilt_Down_Switch_Status;    /* '<S11>/Switch' */\nTILT_INPUT Tilt_Up_Switch_Status;      /* '<S12>/Switch' */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"tilt_tele_switch_func_ROM.c","type":"source","group":"data","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: tilt_tele_switch_func_ROM.c\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"tilt_tele_switch_func.h\"\n#include \"rtwtypes.h\"\n#include \"Tilt_Telescopic_Switch_types.h\"\n\n/* Exported data definition */\n\n/* ConstVolatile memory section */\n/* Definition for custom storage class: ConstVolatile */\nconst volatile uint8_T k_switchdebounce_time = 50U;/* Referenced by:\n                                                    * '<S6>/Constant2'\n                                                    * '<S7>/Constant5'\n                                                    * '<S8>/Constant5'\n                                                    * '<S13>/Constant2'\n                                                    */\nconst volatile uint8_T k_switchrelease_time = 100U;/* Referenced by:\n                                                    * '<S6>/Constant'\n                                                    * '<S7>/Constant3'\n                                                    * '<S8>/Constant3'\n                                                    * '<S13>/Constant'\n                                                    */\nconst volatile uint8_T k_switchstuck_time = 120U;/* Referenced by:\n                                                  * '<S6>/Constant1'\n                                                  * '<S7>/Constant4'\n                                                  * '<S8>/Constant4'\n                                                  * '<S13>/Constant1'\n                                                  */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/jamesbond/Desktop/Tilt_Telescopic_Switch_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'Tilt_Telescopic_Switch'.\n *\n * Model version                  : 1.46\n * Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n * C/C++ source code generated on : Tue Mar 21 15:30:45 2023\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Windows64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Intel->x86-64 (Windows64)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  32\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};